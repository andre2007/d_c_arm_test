import external.libc.config;

#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/spi.h>
#include <libopencm3/stm32/common/spi_common_v1.h>

@nogc:
nothrow:

void blink_gpio_setup()
{
    rcc_periph_clock_enable(RCC_GPIOB);

    gpio_set_mode(GPIOB, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO1);
}

void spi_setup()
{
    // Configure GPIOs:
    gpio_set_mode(
        GPIOB,
        GPIO_MODE_OUTPUT_2_MHZ, // can be 10 MHz
        GPIO_CNF_OUTPUT_ALTFN_PUSHPULL,
        GPIO12 | // CS
        GPIO13 | // CLK
        GPIO15   // Output (MOSI)
    );

    // Input (MISO) config:
    gpio_set_mode(
        GPIOB,
        GPIO_MODE_INPUT,
        GPIO_CNF_INPUT_FLOAT,
        GPIO14
    );

    /* Reset SPI, SPI_CR1 register cleared, SPI is disabled */
    spi_reset(SPI2);

    /* Set up SPI in Master mode with:
    * Clock baud rate: 1/64 of peripheral clock frequency
    * Clock polarity: Idle High
    * Clock phase: Data valid on 2nd clock pulse
    * Data frame format: 8-bit
    * Frame format: MSB First
    */
    spi_init_master(
        SPI2,
        SPI_CR1_BAUDRATE_FPCLK_DIV_64,
        SPI_CR1_CPOL_CLK_TO_1_WHEN_IDLE,
        SPI_CR1_CPHA_CLK_TRANSITION_2,
        SPI_CR1_DFF_8BIT,
        SPI_CR1_MSBFIRST
    );

    /*
    * Set NSS management to software.
    *
    * Note:
    * Setting nss high is very important, even if we are controlling the GPIO
    * ourselves this bit needs to be at least set to 1, otherwise the spi
    * peripheral will not send any data out.
    */
    spi_set_master_mode(SPI2);
    spi_set_unidirectional_mode(SPI2);

    gpio_clear(GPIOB, GPIO12); // one CS line is always LOW in this project

    /* Enable SPI periph. */
    spi_enable(SPI2);
}

void sendDataToSegmentDisplay(ushort data)
{
	spi_send(SPI2, data);
}
